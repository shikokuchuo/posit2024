---
format:
   revealjs:
     slide-number: true
     incremental: true
     footer: "&copy; 2024 Hibiki AI Limited, Eli Lilly and Company"
     view-distance: 100
     mobile-view-distance: 100
---

##

```{r, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  fig.width = 10, 
  fig.height = 5
)
```

<style>
.reveal .tiny {
  display: inline-block;
  font-size: 0.5em;
  line-height: 1.0em;
  vertical-align: top;
}
.reveal .medium {
  display: inline-block;
  font-size: 0.75em;
  line-height: 1.5em;
  vertical-align: top;
}
</style>

<center>
<br>
<h3>mirai and crew: next-generation async to supercharge Plumber, Shiny, and targets</h3>
<img src="./images/title.png" height="400px">
<br>
<h4>Charlie Gao and Will Landau</h4>
</center>

## What is next generation async?

In many modern languages, async is treated as a 'first class' citizen

- Rust has its 'fearless concurrency'
- Go has its Goroutines
- Javascript has its promises

Javascript 'just works'<sup>TM</sup> in your web browser.

## Where we are now in R

- {coro} for coroutines, not true parallelism
- {callr} just for local machine, saves files on filesytem
- {future} just an API, uses backend {parallelly}, not queued

## Bringing first class async to R

::: {.nonincremental}
<img src="./images/nanonext.png" width="160" align="right">

- NNG is a C messaging library
- Incredibly lightweight, brokerless
- Own threaded concurrency framework
- {nanonext} brings NNG capabilities to R

<img src="./images/nng.png">
:::

## mirai

::: {.nonincremental}
<img src="./images/mirai.png" width="160" align="right">

ミライ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / mI ˈ ra ˈ i: /
n. future

Minimalist Async Evaluation Framework for R

- Built on nanonext (single dependency)
- Reduces round-trip task resolution from milliseconds to microseconds
- Designed for production and battle-tested by heavy-duty usage in life sciences industry
:::

## The current generation of promises

- `future_promise()` has never exited 'experimental' status
- Requires constant polling for resolution of each promises

[animated graphic]

<img src="./images/slowcode.png" width="160" align="right">

## The next generation of promises

<span style="color:darkGreen">mirai promises</span>

- Efficient and event-driven
- Zero-latency
- Launch one million promises

[animated graphic]

<img src="./images/shinyvideo.png" width="160" align="right">

## Shiny App that launches and tracks one million promises

[video demo - counter that increments quickly and smoothly]

## Plumber app handling simulatenous requests

[video demo - use `nanonext::ncurl_aio()` to fire off 100 requests]

## Extending mirai

<center>
<img src="./images/crew.png">
</center>

## Science demands heavy computing.

<center>
<img src="./images/pipette.jpg" width=500>
</center>

::: {style="font-size:90%"}

* Bayesian methods help safety/efficacy decisions in clinical trials.
* Each model could take hours to run.
* 1000+ simulations to design a clinical trial.

:::

## Too much work for one laptop

:::: {.columns}

::: {.column width="50%"}

![](./images/hpc1.jpg)

:::

::: {.column width="50%"}

![](./images/hpc2.jpg)

:::

::::

* Clinical trial simulations often need hundreds of computers.
* Need distributed computing: e.g. SLURM clusters, AWS Batch
* Challenges: <b><span style="color:blue">access</span></b>, <b><span style="color:brown">overhead</span></b>, and <b><span style="color:darkGreen">cost</span></b>.


## `crew` scales data science.

![](./images/plugins.png)

1. `mirai` provides low-<b><span style="color:brown">overhead</span></b> interprocess communication.
2. Auto-scaling reduces <b><span style="color:brown">overhead</span></b> and <b><span style="color:darkGreen">cost</span></b>.
3. Plugins <b><span style="color:blue">access</span></b> big high-performance computing systems.

## Low-<b><span style="color:brown">overhead</span></b> communication

![](./images/workers1.png)

## Low-<b><span style="color:brown">overhead</span></b> communication

![](./images/workers2.png)

## Low-<b><span style="color:brown">overhead</span></b> communication

![](./images/workers3.png)

## Low-<b><span style="color:brown">overhead</span></b> communication

![](./images/workers4.png)


## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale1.png)

## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale2.png)

## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale3.png)

## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale4.png)

## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale5.png)

## Auto-scaling reduces <b><span style="color:brown">overhead</span></b> & <b><span style="color:darkGreen">cost</span></b>.

![](./images/autoscale6.png)

## Simple controller interface

<br>

:::: {style="font-size:150%"}

```r
# New controller

controller <- crew_controller_local(
  workers = 2,
  seconds_idle = 10,
  tasks_max = Inf
)
```

::::

## Simple controller interface

<br>

:::: {style="font-size:150%"}

```r
# Submit a task.

controller$push(1 + 1)
```

::::

## Simple controller interface

<br>

:::: {style="font-size:150%"}

```r
# Get the result.

controller$pop()
```

::::

## AWS Batch plugin

:::: {.columns style="font-size:125%"}

::: {.column width="75%"}

<br>

```r
crew_controller_aws_batch(
  workers = 100,
  seconds_idle = 60,
  aws_batch_job_definition = "DEF",
  aws_batch_job_queue = "QUEUE"
)
```
:::

::: {.column width="25%"}

<img src="./images/crew.aws.batch.png">

:::

::::

<br>

* Write your own plugins: <https://wlandau.github.io/crew/articles/plugins.html>

## `crew` unblocks Shiny apps.

:::: {.columns style="font-size:130%"}

```r
observeEvent(input$button, {
  replicate(1000, 
    controller$push(flip_coin(), ...) %...>%
      collect_flips(controller, ...)
  )
})
```

::::

![](./images/coin-flips.gif)

## `crew` accelerates `targets`.

<br>

:::: {.columns style="font-size:115%"}

::: {.column width="75%"}

```r
#_targets.R file

tar_option_set(
  controller = crew_controller_aws_batch(
    workers = 100,
    seconds_idle = 120,
    aws_batch_job_definition = "DEF",
    aws_batch_job_queue = "QUEUE"
  )
)
```

:::

::: {.column width="25%"}

![](./images/targets.png)

:::

::::
